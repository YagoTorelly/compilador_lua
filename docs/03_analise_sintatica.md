# üå≥ An√°lise Sint√°tica (Parsing e AST)

[‚Üê Anterior: An√°lise L√©xica](02_analise_lexica.md) | [‚Üë √çndice](README.md) | [Pr√≥ximo: An√°lise Sem√¢ntica ‚Üí](04_analise_semantica.md)

---

## üìã √çndice

- [O que √© An√°lise Sint√°tica?](#-para-iniciantes-o-que-√©-an√°lise-sint√°tica)
- [√Årvore Sint√°tica Abstrata (AST)](#-√°rvore-sint√°tica-abstrata-ast)
- [Detalhes T√©cnicos](#-detalhes-t√©cnicos)
- [N√≥s da AST](#-n√≥s-da-ast)
- [Recupera√ß√£o de Erros](#-recupera√ß√£o-de-erros)
- [Exemplos Pr√°ticos](#-exemplos-pr√°ticos)

---

## üí° Para Iniciantes: O que √© An√°lise Sint√°tica?

### Defini√ß√£o Simples

**An√°lise sint√°tica** (ou **parsing**) √© o processo de **verificar se os tokens est√£o na ordem correta** e **construir uma estrutura de √°rvore** que representa o programa.

### Analogia: Gram√°tica de Linguagem Natural

Quando voc√™ l√™ uma frase em portugu√™s, verifica automaticamente se a gram√°tica est√° correta:

```
‚úÖ "O gato comeu o peixe."          (correto)
‚ùå "Gato o comeu peixe o."          (errado)
```

O parser faz o mesmo com c√≥digo:

```lua
‚úÖ if x > 5 then print("ok") end    (correto)
‚ùå if x > then 5 print("ok")         (errado)
```

### O que √© uma √Årvore Sint√°tica?

Uma **√°rvore** que representa a estrutura do c√≥digo:

```lua
x = 5 + 3
```

Se transforma em:

```
    ATRIBUI√á√ÉO
      /     \
     x       +
            / \
           5   3
```

### Por que isso √© importante?

- üéØ **Valida** a estrutura do c√≥digo
- üå≥ **Organiza** tokens em hierarquia
- üîç **Facilita** an√°lise sem√¢ntica
- ‚ö° **Permite** gera√ß√£o de c√≥digo

---

## üå≥ √Årvore Sint√°tica Abstrata (AST)

### O que √© AST?

**AST** (Abstract Syntax Tree) √© uma representa√ß√£o **estruturada** do c√≥digo que:
- **Remove** detalhes desnecess√°rios (espa√ßos, pontua√ß√£o)
- **Mant√©m** apenas informa√ß√µes relevantes
- **Organiza** em hierarquia de n√≥s

### Exemplo Visual Completo

**C√≥digo:**
```lua
local x = 10

if x > 5 then
    print("ok")
end
```

**AST:**
```
PROGRAM
‚îú‚îÄ‚îÄ VARIABLE_DECLARATION (local)
‚îÇ   ‚îú‚îÄ‚îÄ Nome: "x"
‚îÇ   ‚îî‚îÄ‚îÄ Valor: LITERAL(10)
‚îÇ
‚îî‚îÄ‚îÄ IF_STATEMENT
    ‚îú‚îÄ‚îÄ Condi√ß√£o: BINARY_OP(>)
    ‚îÇ   ‚îú‚îÄ‚îÄ Esquerda: IDENTIFIER("x")
    ‚îÇ   ‚îî‚îÄ‚îÄ Direita: LITERAL(5)
    ‚îÇ
    ‚îî‚îÄ‚îÄ Bloco:
        ‚îî‚îÄ‚îÄ FUNCTION_CALL
            ‚îú‚îÄ‚îÄ Nome: "print"
            ‚îî‚îÄ‚îÄ Argumentos: [STRING("ok")]
```

---

## üîß Detalhes T√©cnicos

### Localiza√ß√£o no Projeto

```
src/parser/sintatico_moonlet.py
```

**Linhas de c√≥digo:** ~796  
**Classe principal:** `AnalisadorSintaticoMoonlet`  
**N√≥s AST:** 15 classes diferentes

### Estrat√©gia: Recursive Descent Parser

O compilador Moonlet usa **parsing recursivo descendente**, onde:

1. Cada **regra gramatical** = **um m√©todo**
2. M√©todos se **chamam recursivamente**
3. Produz AST **durante o parsing**

```python
class AnalisadorSintaticoMoonlet:
    def _analisar_expressao(self):
        # Chama regras de preced√™ncia
        return self._analisar_expressao_or()
    
    def _analisar_expressao_or(self):
        esquerda = self._analisar_expressao_and()
        while self._verificar_palavra_chave('or'):
            # ...
        return esquerda
    
    def _analisar_expressao_and(self):
        esquerda = self._analisar_expressao_relacional()
        # ...
```

### Estrutura Principal

```python
class AnalisadorSintaticoMoonlet:
    def __init__(self, lexer):
        self.lexer = lexer
        self.token_atual = None
        self.relatorio_erros = RelatorioErros()
        
        # Sem√¢ntica
        self.tabela_simbolos = {}
        self.proximo_endereco = 0
        
        # Gera√ß√£o de c√≥digo MEPA
        self.codigo_mepa = []
        self._contador_rotulos = 0
        
        self._avancar_token()
    
    def analisar(self) -> ProgramNode:
        """Ponto de entrada do parser"""
        declaracoes = []
        while self.token_atual.tipo != EOS:
            decl = self._analisar_declaracao()
            declaracoes.append(decl)
        return ProgramNode(declaracoes)
```

---

## üì¶ N√≥s da AST

### Hierarquia de N√≥s

```
ASTNode (classe base)
‚îú‚îÄ‚îÄ LiteralNode           # Literais: 10, "texto", true
‚îú‚îÄ‚îÄ IdentifierNode        # Identificadores: x, contador
‚îú‚îÄ‚îÄ BinaryOpNode          # Opera√ß√µes: +, -, *, >, ==
‚îú‚îÄ‚îÄ UnaryOpNode           # Opera√ß√µes un√°rias: -, not, #
‚îú‚îÄ‚îÄ FunctionCallNode      # Chamadas: print("ok")
‚îú‚îÄ‚îÄ TableAccessNode       # Acesso: t[1], t.campo
‚îú‚îÄ‚îÄ VariableDeclarationNode  # Declara√ß√µes: local x = 10
‚îú‚îÄ‚îÄ AssignmentNode        # Atribui√ß√µes: x = 5
‚îú‚îÄ‚îÄ IfStatementNode       # Condicionais: if...then...else
‚îú‚îÄ‚îÄ WhileLoopNode         # La√ßo while
‚îú‚îÄ‚îÄ RepeatLoopNode        # La√ßo repeat...until
‚îú‚îÄ‚îÄ ForLoopNode           # La√ßo for num√©rico
‚îú‚îÄ‚îÄ ForInLoopNode         # La√ßo for...in
‚îú‚îÄ‚îÄ BreakNode             # break
‚îú‚îÄ‚îÄ GotoNode              # goto label
‚îú‚îÄ‚îÄ LabelNode             # ::label::
‚îú‚îÄ‚îÄ ReturnNode            # return valores
‚îú‚îÄ‚îÄ FunctionDefinitionNode   # function nome(params)...end
‚îú‚îÄ‚îÄ AnonymousFunctionNode    # function(params)...end
‚îú‚îÄ‚îÄ BlockNode             # Bloco de comandos
‚îî‚îÄ‚îÄ ProgramNode           # Programa completo
```

### N√≥s Principais Explicados

#### 1. LiteralNode

Representa valores constantes:

```python
class LiteralNode(ASTNode):
    def __init__(self, valor, tipo):
        self.valor = valor  # 10, "texto", True, None
        self.tipo = tipo    # 'number', 'string', 'boolean', 'nil'
```

**Exemplos:**
```lua
10          ‚Üí LiteralNode(10, 'number')
"hello"     ‚Üí LiteralNode("hello", 'string')
true        ‚Üí LiteralNode(True, 'boolean')
nil         ‚Üí LiteralNode(None, 'nil')
```

#### 2. IdentifierNode

Representa nomes de vari√°veis/fun√ß√µes:

```python
class IdentifierNode(ASTNode):
    def __init__(self, nome):
        self.nome = nome  # "x", "contador", "print"
```

#### 3. BinaryOpNode

Representa opera√ß√µes bin√°rias:

```python
class BinaryOpNode(ASTNode):
    def __init__(self, operador, esquerda, direita):
        self.operador = operador  # '+', '-', '>', '==', etc.
        self.esquerda = esquerda  # N√≥ esquerdo
        self.direita = direita    # N√≥ direito
```

**Exemplo:**
```lua
x + 5
```

Se torna:
```
BinaryOpNode('+')
‚îú‚îÄ‚îÄ esquerda: IdentifierNode('x')
‚îî‚îÄ‚îÄ direita: LiteralNode(5)
```

#### 4. IfStatementNode

Representa estruturas condicionais:

```python
class IfStatementNode(ASTNode):
    def __init__(self, condicoes, blocos, bloco_else=None):
        self.condicoes = condicoes  # Lista de condi√ß√µes (if, elseif, ...)
        self.blocos = blocos        # Lista de blocos correspondentes
        self.bloco_else = bloco_else  # Bloco else (opcional)
```

**Exemplo:**
```lua
if x > 10 then
    print("grande")
elseif x > 5 then
    print("m√©dio")
else
    print("pequeno")
end
```

Se torna:
```
IfStatementNode
‚îú‚îÄ‚îÄ condicoes[0]: BinaryOpNode('>', IdentifierNode('x'), LiteralNode(10))
‚îú‚îÄ‚îÄ blocos[0]: [FunctionCallNode('print', ["grande"])]
‚îú‚îÄ‚îÄ condicoes[1]: BinaryOpNode('>', IdentifierNode('x'), LiteralNode(5))
‚îú‚îÄ‚îÄ blocos[1]: [FunctionCallNode('print', ["m√©dio"])]
‚îî‚îÄ‚îÄ bloco_else: [FunctionCallNode('print', ["pequeno"])]
```

#### 5. WhileLoopNode

```python
class WhileLoopNode(ASTNode):
    def __init__(self, condicao, corpo):
        self.condicao = condicao  # Express√£o de condi√ß√£o
        self.corpo = corpo        # Lista de comandos
```

#### 6. ForLoopNode

```python
class ForLoopNode(ASTNode):
    def __init__(self, variavel, inicio, fim, passo, corpo):
        self.variavel = variavel  # Nome da vari√°vel de controle
        self.inicio = inicio      # Express√£o inicial
        self.fim = fim            # Express√£o final
        self.passo = passo        # Express√£o de passo (opcional)
        self.corpo = corpo        # Lista de comandos
```

#### 7. FunctionCallNode

```python
class FunctionCallNode(ASTNode):
    def __init__(self, nome, argumentos):
        self.nome = nome          # Nome da fun√ß√£o
        self.argumentos = argumentos  # Lista de express√µes
```

#### 8. VariableDeclarationNode

```python
class VariableDeclarationNode(ASTNode):
    def __init__(self, nome, valor, local=False):
        self.nome = nome      # Nome da vari√°vel
        self.valor = valor    # Express√£o de inicializa√ß√£o
        self.local = local    # True se declarada com 'local'
```

---

## üîÑ Pattern Visitor

### O que √©?

O **Pattern Visitor** permite percorrer a AST sem modificar as classes dos n√≥s.

### Implementa√ß√£o

Todos os n√≥s implementam:

```python
class ASTNode:
    def accept(self, visitor):
        """Aceita um visitante"""
        class_name = self.__class__.__name__.lower().replace('node', '')
        method_name = f'visit_{class_name}'
        method = getattr(visitor, method_name, None)
        if method:
            return method(self)
```

### Exemplo: Impressor de AST

```python
class ImpressorAST:
    def visit_literal(self, node):
        print(f"LITERAL ({node.tipo}): {node.valor}")
    
    def visit_binary_op(self, node):
        print(f"OPERA√á√ÉO: {node.operador}")
        node.esquerda.accept(self)
        node.direita.accept(self)
```

**Uso:**
```python
ast = parser.analisar()
impressor = ImpressorAST()
ast.accept(impressor)
```

---

## üìä Preced√™ncia de Operadores

O parser respeita a **preced√™ncia de operadores** usando m√©todos hier√°rquicos:

```
Preced√™ncia (maior ‚Üí menor):

1. Prim√°rias:    literais, identificadores, ( )
2. Un√°rias:      -, not, #
3. Multiplicativas:  *, /, %, ^
4. Aditivas:     +, -
5. Concatena√ß√£o: ..
6. Relacionais:  <, >, <=, >=, ==, ~=
7. And:          and
8. Or:           or
```

### Implementa√ß√£o

```python
def _analisar_expressao(self):
    return self._analisar_expressao_or()  # Menor preced√™ncia

def _analisar_expressao_or(self):
    esquerda = self._analisar_expressao_and()
    while self._verificar_palavra_chave('or'):
        # ...
    return esquerda

def _analisar_expressao_and(self):
    esquerda = self._analisar_expressao_relacional()
    # ...

def _analisar_expressao_relacional(self):
    esquerda = self._analisar_expressao_concat()
    # ...

def _analisar_expressao_concat(self):
    esquerda = self._analisar_expressao_aditiva()
    # ...

def _analisar_expressao_aditiva(self):
    esquerda = self._analisar_expressao_multiplicativa()
    # ...

def _analisar_expressao_multiplicativa(self):
    esquerda = self._analisar_expressao_unaria()
    # ...

def _analisar_expressao_unaria(self):
    # not, -, #
    return self._analisar_expressao_primaria()

def _analisar_expressao_primaria(self):
    # Literais, identificadores, ( ), fun√ß√µes an√¥nimas
```

### Exemplo de Preced√™ncia

```lua
x = 2 + 3 * 4
```

**Parsing:**
```
_analisar_expressao()
  ‚îî‚îÄ _analisar_expressao_or()
      ‚îî‚îÄ _analisar_expressao_and()
          ‚îî‚îÄ _analisar_expressao_relacional()
              ‚îî‚îÄ _analisar_expressao_concat()
                  ‚îî‚îÄ _analisar_expressao_aditiva()  ‚Üê Aqui!
                      ‚îú‚îÄ esquerda: 2
                      ‚îú‚îÄ operador: +
                      ‚îî‚îÄ direita: _analisar_expressao_multiplicativa()
                          ‚îú‚îÄ esquerda: 3
                          ‚îú‚îÄ operador: *
                          ‚îî‚îÄ direita: 4
```

**AST resultante:**
```
ASSIGNMENT
‚îú‚îÄ‚îÄ variavel: IDENTIFIER('x')
‚îî‚îÄ‚îÄ valor: BINARY_OP(+)
    ‚îú‚îÄ‚îÄ esquerda: LITERAL(2)
    ‚îî‚îÄ‚îÄ direita: BINARY_OP(*)
        ‚îú‚îÄ‚îÄ esquerda: LITERAL(3)
        ‚îî‚îÄ‚îÄ direita: LITERAL(4)
```

Resultado correto: `2 + (3 * 4) = 14`

---

## ‚ö†Ô∏è Recupera√ß√£o de Erros

### Estrat√©gia: Panic Mode

Quando o parser encontra um erro, ele tenta **recuperar** para continuar analisando:

```python
def _analisar_comando_if(self):
    self._consumir_palavra_chave('if')
    condicao = self._analisar_expressao()
    
    # ‚úÖ Tenta consumir 'then'
    if self._verificar_palavra_chave('then'):
        self._avancar_token()
    else:
        # ‚ùå ERRO: Reporta mas continua
        erro = criar_erro_token_esperado('then', ...)
        self.relatorio_erros.adicionar_erro(erro)
        print(f"‚ö†Ô∏è ERRO SINT√ÅTICO: {erro}")
    
    # Continua parsing do bloco
    bloco = self._analisar_bloco()
    # ...
```

### Pontos de Sincroniza√ß√£o

O parser tenta se recuperar pulando para tokens "seguros":

```python
def _pular_ate_proximo_valido(self):
    """Pula tokens at√© encontrar palavra-chave ou identificador"""
    while (self.token_atual and 
           self.token_atual.tipo not in [EOS, PALAVRA_CHAVE] and
           not (self.token_atual.tipo == IDENTIFICADOR)):
        print(f"üîÑ Pulando token: '{self.token_atual.lexema}'")
        self._avancar_token()
```

### Exemplo de Recupera√ß√£o

**C√≥digo com erro:**
```lua
if x > 5  -- ‚ùå FALTA 'then'
    print("ok")
end
```

**Comportamento:**
```
‚ö†Ô∏è ERRO SINT√ÅTICO: Esperado 'then', encontrado 'print'
üîÑ Parser continua...
‚úì Bloco analisado
‚úì 'end' encontrado
```

**Resultado:**
- ‚ùå Erro reportado
- ‚úÖ AST parcial gerado
- ‚úÖ An√°lise continua

---

## üìù Exemplos Pr√°ticos

### Exemplo 1: Express√£o Simples

**C√≥digo:**
```lua
x = 5 + 3
```

**AST:**
```
PROGRAM
‚îî‚îÄ‚îÄ ASSIGNMENT
    ‚îú‚îÄ‚îÄ variavel: IDENTIFIER("x")
    ‚îî‚îÄ‚îÄ valor: BINARY_OP(+)
        ‚îú‚îÄ‚îÄ esquerda: LITERAL(5)
        ‚îî‚îÄ‚îÄ direita: LITERAL(3)
```

### Exemplo 2: Condicional

**C√≥digo:**
```lua
if x > 10 then
    print("grande")
else
    print("pequeno")
end
```

**AST:**
```
PROGRAM
‚îî‚îÄ‚îÄ IF_STATEMENT
    ‚îú‚îÄ‚îÄ condicoes[0]: BINARY_OP(>)
    ‚îÇ   ‚îú‚îÄ‚îÄ esquerda: IDENTIFIER("x")
    ‚îÇ   ‚îî‚îÄ‚îÄ direita: LITERAL(10)
    ‚îú‚îÄ‚îÄ blocos[0]:
    ‚îÇ   ‚îî‚îÄ‚îÄ FUNCTION_CALL("print")
    ‚îÇ       ‚îî‚îÄ‚îÄ argumentos: [STRING("grande")]
    ‚îî‚îÄ‚îÄ bloco_else:
        ‚îî‚îÄ‚îÄ FUNCTION_CALL("print")
            ‚îî‚îÄ‚îÄ argumentos: [STRING("pequeno")]
```

### Exemplo 3: La√ßo While

**C√≥digo:**
```lua
local i = 1
while i <= 5 do
    i = i + 1
end
```

**AST:**
```
PROGRAM
‚îú‚îÄ‚îÄ VARIABLE_DECLARATION (local)
‚îÇ   ‚îú‚îÄ‚îÄ nome: "i"
‚îÇ   ‚îî‚îÄ‚îÄ valor: LITERAL(1)
‚îÇ
‚îî‚îÄ‚îÄ WHILE_LOOP
    ‚îú‚îÄ‚îÄ condicao: BINARY_OP(<=)
    ‚îÇ   ‚îú‚îÄ‚îÄ esquerda: IDENTIFIER("i")
    ‚îÇ   ‚îî‚îÄ‚îÄ direita: LITERAL(5)
    ‚îÇ
    ‚îî‚îÄ‚îÄ corpo:
        ‚îî‚îÄ‚îÄ ASSIGNMENT
            ‚îú‚îÄ‚îÄ variavel: IDENTIFIER("i")
            ‚îî‚îÄ‚îÄ valor: BINARY_OP(+)
                ‚îú‚îÄ‚îÄ esquerda: IDENTIFIER("i")
                ‚îî‚îÄ‚îÄ direita: LITERAL(1)
```

### Exemplo 4: La√ßo For

**C√≥digo:**
```lua
for i = 1, 10, 2 do
    print(i)
end
```

**AST:**
```
PROGRAM
‚îî‚îÄ‚îÄ FOR_LOOP
    ‚îú‚îÄ‚îÄ variavel: "i"
    ‚îú‚îÄ‚îÄ inicio: LITERAL(1)
    ‚îú‚îÄ‚îÄ fim: LITERAL(10)
    ‚îú‚îÄ‚îÄ passo: LITERAL(2)
    ‚îî‚îÄ‚îÄ corpo:
        ‚îî‚îÄ‚îÄ FUNCTION_CALL("print")
            ‚îî‚îÄ‚îÄ argumentos: [IDENTIFIER("i")]
```

### Exemplo 5: Fun√ß√£o

**C√≥digo:**
```lua
function soma(a, b)
    return a + b
end
```

**AST:**
```
PROGRAM
‚îî‚îÄ‚îÄ FUNCTION_DEFINITION
    ‚îú‚îÄ‚îÄ nome: "soma"
    ‚îú‚îÄ‚îÄ parametros: ["a", "b"]
    ‚îî‚îÄ‚îÄ corpo:
        ‚îî‚îÄ‚îÄ RETURN
            ‚îî‚îÄ‚îÄ valores: [BINARY_OP(+)
                ‚îú‚îÄ‚îÄ esquerda: IDENTIFIER("a")
                ‚îî‚îÄ‚îÄ direita: IDENTIFIER("b")]
```

---

## üõ†Ô∏è M√©todos Principais do Parser

### 1. Declara√ß√µes

```python
def _analisar_declaracao(self) -> ASTNode:
    """Analisa uma declara√ß√£o de alto n√≠vel"""
    if self._verificar_palavra_chave('local'):
        return self._analisar_declaracao_variavel()
    
    if self._verificar_palavra_chave('function'):
        return self._analisar_definicao_funcao()
    
    if self._verificar_simbolo('::'):
        return self._analisar_label()
    
    return self._analisar_comando()
```

### 2. Comandos

```python
def _analisar_comando(self) -> ASTNode:
    """Analisa um comando"""
    if self._verificar_palavra_chave('if'):
        return self._analisar_comando_if()
    
    if self._verificar_palavra_chave('while'):
        return self._analisar_comando_while()
    
    if self._verificar_palavra_chave('for'):
        return self._analisar_comando_for()
    
    if self._verificar_token(IDENTIFICADOR):
        return self._analisar_atribuicao_ou_chamada()
    
    # ...
```

### 3. Express√µes

```python
def _analisar_expressao(self) -> ASTNode:
    """Ponto de entrada para express√µes"""
    return self._analisar_expressao_or()
```

---

## üß™ Testando o Parser

### C√≥digo de Teste

```python
from src.lexer.lexico_moonlet import AnalisadorLexicoMoonlet
from src.parser.sintatico_moonlet import AnalisadorSintaticoMoonlet

codigo = """
local x = 10
if x > 5 then
    print("ok")
end
"""

lexer = AnalisadorLexicoMoonlet(codigo)
parser = AnalisadorSintaticoMoonlet(lexer)

ast = parser.analisar()

# Imprimir AST
from src.ast.compilador_moonlet import ImpressorAST
impressor = ImpressorAST()
ast.accept(impressor)
```

### Sa√≠da Esperada

```
PROGRAMA
  local DECLARA√á√ÉO: x
    VALOR:
      LITERAL (number): 10
  IF-STATEMENT
    IF:
      CONDI√á√ÉO:
        OPERA√á√ÉO: >
          ESQUERDA:
            IDENTIFICADOR: x
          DIREITA:
            LITERAL (number): 5
      BLOCO:
        CHAMADA: print
          ARGUMENTOS:
            LITERAL (string): ok
```

---

## ‚úÖ Resumo

### O que o Analisador Sint√°tico faz?

‚úÖ Verifica estrutura gramatical  
‚úÖ Constr√≥i AST  
‚úÖ Respeita preced√™ncia de operadores  
‚úÖ Recupera de erros sint√°ticos  
‚úÖ Prepara para an√°lise sem√¢ntica  

### O que ele N√ÉO faz?

‚ùå Verificar significado (an√°lise sem√¢ntica)  
‚ùå Otimizar c√≥digo  
‚ùå Executar o programa  

---

## üéØ Pr√≥ximos Passos

Agora que voc√™ entende como a AST √© constru√≠da, vamos ver como verificamos se o c√≥digo **faz sentido**:

[‚ñ∂Ô∏è Pr√≥ximo: An√°lise Sem√¢ntica ‚Üí](04_analise_semantica.md)

Ou explore outros t√≥picos:

- [üîç Voltar √† An√°lise L√©xica](02_analise_lexica.md)
- [üìö Ver Exemplos Pr√°ticos](08_exemplos_uso.md)
- [üîß Refer√™ncia T√©cnica Completa](09_referencia_tecnica.md)

---

[‚Üê Anterior: An√°lise L√©xica](02_analise_lexica.md) | [‚Üë √çndice](README.md) | [Pr√≥ximo: An√°lise Sem√¢ntica ‚Üí](04_analise_semantica.md)

